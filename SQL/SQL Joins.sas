libname IPEDS '~/IPEDS';
options fmtsearch=(IPEDS);

proc sql;
  select ch.unitID label='ID from Char.',
         gr.unitID label='ID from Grad.',
         ch.control, gr.total 
    from ipeds.Characteristics(obs=3) as ch, 
         ipeds.Graduation(obs=2) as gr 
          /**If you list multiple tables in the FROM
            clause (comma separated) with no other
            instructions, you get a Cartesian product
            of the records**/
    where group contains 'Incoming'
;
quit;

proc sql;
  create table Inner1 as
  select ch.unitID label='Inst. ID', instnm, total, group
    from ipeds.Characteristics as ch inner join ipeds.Graduation as gr
        on gr.unitID eq ch.unitID
      /**INNER JOIN keeps rows generated by matches corresponding to
          the ON criterion**/
  ;
quit;
proc sql;
  create table Inner2 as
  select ch.unitID label='Inst. ID', instnm, total, group
    from ipeds.Characteristics as ch, ipeds.graduation as gr
        /**A comma separated list of tables generates a Cartesian
            product...**/
    where gr.unitID eq ch.unitID 
      /**...but a WHERE condition can limit it to matches**/
  ;
quit;


proc sql;
  create table multipleJoin as
  select ch.unitID label='Inst. ID', instnm, total, group,
          tuition2 label='In State' format=comma9.,
          tuition3 label='Out of State' format=comma9.
    from ipeds.Characteristics as ch,
         ipeds.Graduation as gr,
         ipeds.TuitionAndCosts as tc 
    where gr.unitID eq ch.unitID eq tc.unitID 
  ;
quit;

proc sql;
  create table multipleJoin2 as
  select ch.unitID label='Inst. ID', instnm, total, group,
          tuition2 label='In State' format=comma9.,
          tuition3 label='Out of State' format=comma9.
  from (ipeds.Characteristics as ch inner join ipeds.Graduation as gr
         on ch.unitID eq gr.unitID) /**we do an inner join of two tables...**/
        inner join ipeds.TuitionAndCosts as tc
          on gr.unitID eq tc.unitID /**joining the result to the other one**/
  ;
  create table multipleJoin3 as
  select ch.unitID label='Inst. ID', instnm, total, group,
          tuition2 label='In State' format=comma9.,
          tuition3 label='Out of State' format=comma9.
  from (ipeds.Characteristics as ch inner join ipeds.Graduation as gr
         on gr.unitID eq ch.unitID)
        inner join ipeds.TuitionAndCosts as tc
          on ch.unitID eq tc.unitID 
  where tuition3 ge 15000 and group contains 'Incoming' 
    /**Now a subsetting WHERE can be separated from
        a row matching condition**/
  ;
quit;


proc sql;
  create table avgTuition as
    select control,
      mean(tuition2) label='Avg. In-State Tuition' format=dollar12.2 as AvgInState,
      mean(tuition3) label='Avg. Out-of-State Tuition' format=dollar12.2 as AvgOutState,
      calculated AvgOutState - calculated AvgInState format=dollar12.2
          label='Avg. Difference' as AvgDiff,
      mean(tuition3/tuition2 gt 2) label='Proportion with Out:In State at least 2'
          format=percent8.1 as HighOOS 
    from ipeds.Characteristics as ch inner join ipeds.TuitionAndCosts as tc
          on ch.unitID eq tc.unitID 
    where tuition3 gt tuition2 and tuition2 gt 0 and control gt 0 
    group by control
  ;
quit;

proc sql;
  create table anotherJoin as
  select ch.instnm, ch.Control, total, AvgOutState
    from (ipeds.Characteristics as ch inner join ipeds.Graduation as gr
            on ch.unitid eq gr.unitid) 
          inner join avgTuition as avT  on avT.Control eq ch.Control 
                     /**Control is in the Characterisitcs ^^ table**/
    where group contains 'Incoming' and total ge 450 
    order by total
    ;
  create table anotherJoinB as
  select ch.instnm, ch.Control, total, AvgOutState
    from (ipeds.Characteristics as ch inner join ipeds.Graduation as gr
            on ch.unitid eq gr.unitid) as one
              /**Cannot alias a join...**/
          inner join avgTuition as avT  on avT.Control eq one.Control 
    where group contains 'Incoming' and total ge 450 
    order by total
    ;
quit;

proc sql;
  select avTA.Control label='Control A', avTA.AvgInState as A,
         avTB.Control label='Control B', avTB.AvgInState as B,
         A-B label='Difference (A-B)' format=dollar12.2
    from avgTuition as avTA inner join avgTuition as avTB 
          on avTA.Control ne avTB.Control 
  ;
  select avTA.Control label='Control A', avTA.AvgInState as A,
         avTB.Control label='Control B', avTB.AvgInState as B,
         A-B label='Difference (A-B)' format=dollar12.2
    from avgTuition as avTA inner join avgTuition as avTB 
          on avTA.Control lt avTB.Control 
  ;
  select avTA.Control label='Control A', avTA.AvgInState as A,
         avTB.Control label='Control B', avTB.AvgInState as B,
         A-B label='Difference (A-B)' as Diff format=dollar12.2
    from avgTuition as avTA inner join avgTuition as avTB 
          on avTA.Control ne avTB.Control 
    where calculated Diff ge 0
    order by Diff desc
  ;
quit;


libname SASData '~/SASData';
proc sql;
  create table FullJoin as 
    select ParkName, ParkCode, Traf2016.* 
    from SASData.np_codeLookUp full join 
          SASData.np_2016Traffic as Traf2016
             on ParkCode eq Code 
  ;/**FULL JOIN is like the DATA step match merge
      default logic...preserve all mismatches and matches***/
quit;

proc sql;
  create table FullJoin as 
    select ParkName, ParkCode, Traf2016.* 
    from SASData.np_codeLookUp full join 
          SASData.np_2016Traffic as Traf2016
             on ParkCode eq Code 
  ;
  create table LeftJoin as 
    select ParkName, ParkCode, Traf2016.* 
    from SASData.np_codeLookUp left join 
          SASData.np_2016Traffic as Traf2016
             on ParkCode eq Code 
  ;/**LEFT JOIN preserves all records from the "left"/first
      table...**/
  create table RightJoin as 
    select ParkName, ParkCode, Traf2016.* 
    from SASData.np_codeLookUp right join 
          SASData.np_2016Traffic as Traf2016
             on ParkCode eq Code 
  ;/**RIGHT JOIN keeps all from the "right"/second table**/
  create table InnerJoin as 
    select ParkName, ParkCode, Traf2016.* 
    from SASData.np_codeLookUp inner join 
          SASData.np_2016Traffic as Traf2016
             on ParkCode eq Code 
  ;
quit;
